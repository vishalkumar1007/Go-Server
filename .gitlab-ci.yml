# .gitlab-ci.yml
<<<<<<< HEAD
# GitLab CI Pipeline with GitHub Actions Integration
stages:
  - build
  - test  
=======
# GitLab CI Pipeline that triggers GitHub Actions workflows & monitors log

stages:
  - build
  - test
>>>>>>> main
  - deploy-dev
  - deploy-qa
  - deploy-prod
  - deploy-next

variables:
  GO_VERSION: "1.21"
  GITHUB_REPO: "vishalkumar1007/Go-Server"
  GITLAB_PROJECT_ID: "71610967"

<<<<<<< HEAD



# Auto Build Stage
=======
# Build Stage
>>>>>>> main
build:
  stage: build
  image: golang:${GO_VERSION}
  script:
<<<<<<< HEAD
    - echo "üèóÔ∏è Building application..."
=======
    - 'echo "üèóÔ∏è Building application..."'
>>>>>>> main
    - go mod download
    - go build -o app main.go
    - 'echo "‚úÖ Build completed"'
  artifacts:
    paths:
      - app
      - monitor/
    expire_in: 1 hour
  only:
    - main
    - develop
    - /^feature\/.*$/
    - /^bugfix\/.*$/

<<<<<<< HEAD
# Auto Test Stage  
=======
# Test Stage
>>>>>>> main
test:
  stage: test
  image: golang:${GO_VERSION}
  script:
<<<<<<< HEAD
    - echo "üß™ Running tests..."
=======
    - 'echo "üß™ Running tests..."'
>>>>>>> main
    - go mod download
    - go vet ./...
    - go test -v ./...
    - 'echo "‚úÖ All tests passed"'
  only:
    - main
    - develop
    - /^feature\/.*$/
    - /^bugfix\/.*$/

# Template for all deployment environments
.deploy_template: &deploy_template
  image: golang:${GO_VERSION}
  script:
    - 'echo "üöÄ Triggering GitHub Actions deployment to ${ENVIRONMENT^^}..."'
    - 'echo "üì° Triggering GitHub Workflow Dispatch via API..."'
    - |
      curl -s -X POST "https://api.github.com/repos/${GITHUB_REPO}/actions/workflows/deploy.yml/dispatches" \
        -H "Authorization: Bearer ${GITHUB_TOKEN}" \
        -H "Accept: application/vnd.github+json" \
        -d "{\"ref\":\"${BRANCH_NAME}\", \"inputs\":{\"environment\":\"${ENVIRONMENT}\"}}"
    - 'echo "üñ•Ô∏è Monitoring GitHub Actions workflow for branch: ${BRANCH_NAME}"'
    - cd monitor
    - go mod init github-monitor 2>/dev/null || true
    - go mod tidy
    - go build -o github-monitor main.go
    - export GITHUB_TOKEN="${GITHUB_TOKEN}"
    - export GITHUB_REPO="${GITHUB_REPO}"
    - export GITLAB_TOKEN="${GITLAB_TOKEN}"
    - export GITLAB_PROJECT_ID="${GITLAB_PROJECT_ID}"
    - export BRANCH_NAME="${BRANCH_NAME}"
    - export ENVIRONMENT="${ENVIRONMENT}"
    - 'export POLL_INTERVAL="10s"'
    - 'echo "üîç Starting real-time GitHub Actions monitoring..."'
    - ./github-monitor
  artifacts:
    when: always
    paths:
      - monitor/gitlab-logs/
    expire_in: 1 week
  when: manual
  only:
    - main
    - develop
    - /^feature\/.*$/
    - /^bugfix\/.*$/

<<<<<<< HEAD
# Manual Deploy to DEV Environment
deploy-dev:
  stage: deploy-dev
  image: golang:${GO_VERSION}
  variables:
    ENVIRONMENT: "dev"
    BRANCH_NAME: "dev"
  script:
    - echo "üöÄ Triggering GitHub Actions deployment to DEV environment..."
    - echo "üì° Monitoring GitHub Actions workflow for branch: ${BRANCH_NAME}"
    
    # Build and run the monitor
    - cd monitor
    - go mod init github-monitor 2>/dev/null || true
    - go mod tidy
    - go build -o github-monitor main.go
    
    # Run the monitor with environment variables
    - export GITHUB_TOKEN="${GITHUB_TOKEN}"
    - export GITHUB_REPO="${GITHUB_REPO}"
    - export GITLAB_TOKEN="${GITLAB_TOKEN}"
    - export GITLAB_PROJECT_ID="${GITLAB_PROJECT_ID}"
    - export BRANCH_NAME="${BRANCH_NAME}"
    - export ENVIRONMENT="${ENVIRONMENT}"
    - export POLL_INTERVAL="10s"
    
    # Start monitoring
    - echo "üîç Starting real-time GitHub Actions monitoring..."
    - ./github-monitor
    
=======
# Manual Deploy: DEV
deploy-dev:
  stage: deploy-dev
  variables:
    ENVIRONMENT: "dev"
    BRANCH_NAME: "dev"
  <<: *deploy_template

# Manual Deploy: QA
deploy-qa:
  stage: deploy-qa
  variables:
    ENVIRONMENT: "qa"
    BRANCH_NAME: "qa"
  <<: *deploy_template

# Manual Deploy: PROD
deploy-prod:
  stage: deploy-prod
  variables:
    ENVIRONMENT: "prod"
    BRANCH_NAME: "main"
  <<: *deploy_template
>>>>>>> main
  artifacts:
    when: always
    paths:
      - monitor/gitlab-logs/
<<<<<<< HEAD
    expire_in: 1 week
    reports:
      junit: monitor/gitlab-logs/*.xml
  when: manual
  only:
    - main

# Manual Deploy to QA Environment
deploy-qa:
  stage: deploy-qa
  image: golang:${GO_VERSION}
  variables:
    ENVIRONMENT: "qa"
    BRANCH_NAME: "qa"
  script:
    - echo "üöÄ Triggering GitHub Actions deployment to QA environment..."
    - echo "üì° Monitoring GitHub Actions workflow for branch: ${BRANCH_NAME}"
    
    # Build and run the monitor
    - cd monitor
    - go mod init github-monitor 2>/dev/null || true
    - go mod tidy
    - go build -o github-monitor main.go
    
    # Run the monitor with environment variables
    - export GITHUB_TOKEN="${GITHUB_TOKEN}"
    - export GITHUB_REPO="${GITHUB_REPO}"
    - export GITLAB_TOKEN="${GITLAB_TOKEN}"
    - export GITLAB_PROJECT_ID="${GITLAB_PROJECT_ID}"
    - export BRANCH_NAME="${BRANCH_NAME}"
    - export ENVIRONMENT="${ENVIRONMENT}"
    - export POLL_INTERVAL="10s"
    
    # Start monitoring
    - echo "üîç Starting real-time GitHub Actions monitoring..."
    - ./github-monitor
    
  artifacts:
    when: always
    paths:
      - monitor/gitlab-logs/
    expire_in: 1 week
  when: manual
  only:
    - main

# Manual Deploy to PROD Environment
deploy-prod:
  stage: deploy-prod
  image: golang:${GO_VERSION}
  variables:
    ENVIRONMENT: "prod"
    BRANCH_NAME: "main"
  script:
    - echo "üöÄ Triggering GitHub Actions deployment to PRODUCTION environment..."
    - echo "üì° Monitoring GitHub Actions workflow for branch: ${BRANCH_NAME}"
    - echo "‚ö†Ô∏è PRODUCTION DEPLOYMENT - Monitoring carefully..."
    
    # Build and run the monitor
    - cd monitor
    - go mod init github-monitor 2>/dev/null || true
    - go mod tidy
    - go build -o github-monitor main.go
    
    # Run the monitor with environment variables
    - export GITHUB_TOKEN="${GITHUB_TOKEN}"
    - export GITHUB_REPO="${GITHUB_REPO}"
    - export GITLAB_TOKEN="${GITLAB_TOKEN}"
    - export GITLAB_PROJECT_ID="${GITLAB_PROJECT_ID}"
    - export BRANCH_NAME="${BRANCH_NAME}"
    - export ENVIRONMENT="${ENVIRONMENT}"
    - export POLL_INTERVAL="5s"  # More frequent polling for production
    
    # Start monitoring
    - echo "üîç Starting real-time GitHub Actions monitoring..."
    - ./github-monitor
    
  artifacts:
    when: always
    paths:
      - monitor/gitlab-logs/
    expire_in: 1 month  # Keep prod logs longer
  when: manual
  only:
    - main

# Manual Deploy to NEXT Environment
deploy-next:
  stage: deploy-next
  image: golang:${GO_VERSION}
  variables:
    ENVIRONMENT: "next"
    BRANCH_NAME: "next"
  script:
    - echo "üöÄ Triggering GitHub Actions deployment to NEXT environment..."
    - echo "üì° Monitoring GitHub Actions workflow for branch: ${BRANCH_NAME}"
    
    # Build and run the monitor
    - cd monitor
    - go mod init github-monitor 2>/dev/null || true
    - go mod tidy
    - go build -o github-monitor main.go
    
    # Run the monitor with environment variables
    - export GITHUB_TOKEN="${GITHUB_TOKEN}"
    - export GITHUB_REPO="${GITHUB_REPO}"
    - export GITLAB_TOKEN="${GITLAB_TOKEN}"
    - export GITLAB_PROJECT_ID="${GITLAB_PROJECT_ID}"
    - export BRANCH_NAME="${BRANCH_NAME}"
    - export ENVIRONMENT="${ENVIRONMENT}"
    - export POLL_INTERVAL="10s"
    
    # Start monitoring
    - echo "üîç Starting real-time GitHub Actions monitoring..."
    - ./github-monitor
    
  artifacts:
    when: always
    paths:
      - monitor/gitlab-logs/
    expire_in: 1 week
  when: manual
  only:
    - main
=======
    expire_in: 1 month

# Manual Deploy: NEXT
deploy-next:
  stage: deploy-next
  variables:
    ENVIRONMENT: "next"
    BRANCH_NAME: "next"
  <<: *deploy_template
>>>>>>> main

# Optional: Cleanup job
cleanup:
  stage: .post
  image: alpine:latest
  script:
<<<<<<< HEAD
    - echo "üßπ Cleaning up temporary files..."
    - rm -rf /tmp/github-monitor-*
  when: always
  allow_failure: true




=======
    - 'echo "üßπ Cleaning up temporary files..."'
    - rm -rf /tmp/github-monitor-*
  when: always
  allow_failure: true
>>>>>>> main
