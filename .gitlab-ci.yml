# .gitlab-ci.yml
# GitLab CI Pipeline with GitHub Actions Integration
stages:
  - build
  - test  
  - deploy-dev
  - deploy-qa
  - deploy-prod
  - deploy-next

variables:
  GO_VERSION: "1.21"
  GITHUB_REPO: "vishalkumar1007/Go-Server"
  GITLAB_PROJECT_ID: "71610967"




# Auto Build Stage
build:
  stage: build
  image: golang:${GO_VERSION}
  script:
    - echo "üèóÔ∏è Building application..."
    - go mod download
    - go build -o app main.go
    - echo "‚úÖ Build completed successfully"
  artifacts:
    paths:
      - app
      - monitor/
    expire_in: 1 hour
  only:
    - main
    - develop
    - /^feature\/.*$/
    - /^bugfix\/.*$/

# Auto Test Stage  
test:
  stage: test
  image: golang:${GO_VERSION}
  script:
    - echo "üß™ Running tests..."
    - go mod download
    - go vet ./...
    - go test -v ./...
    - echo "‚úÖ All tests passed"
  only:
    - main
    - develop
    - /^feature\/.*$/
    - /^bugfix\/.*$/

# Manual Deploy to DEV Environment
deploy-dev:
  stage: deploy-dev
  image: golang:${GO_VERSION}
  variables:
    ENVIRONMENT: "dev"
    BRANCH_NAME: "dev"
  script:
    - echo "üöÄ Triggering GitHub Actions deployment to DEV environment..."
    - echo "üì° Monitoring GitHub Actions workflow for branch: ${BRANCH_NAME}"
    
    # Build and run the monitor
    - cd monitor
    - go mod init github-monitor 2>/dev/null || true
    - go mod tidy
    - go build -o github-monitor main.go
    
    # Run the monitor with environment variables
    - export GITHUB_TOKEN="${GITHUB_TOKEN}"
    - export GITHUB_REPO="${GITHUB_REPO}"
    - export GITLAB_TOKEN="${GITLAB_TOKEN}"
    - export GITLAB_PROJECT_ID="${GITLAB_PROJECT_ID}"
    - export BRANCH_NAME="${BRANCH_NAME}"
    - export ENVIRONMENT="${ENVIRONMENT}"
    - export POLL_INTERVAL="10s"
    
    # Start monitoring
    - echo "üîç Starting real-time GitHub Actions monitoring..."
    - ./github-monitor
    
  artifacts:
    when: always
    paths:
      - monitor/gitlab-logs/
    expire_in: 1 week
    reports:
      junit: monitor/gitlab-logs/*.xml
  when: manual
  only:
    - main

# Manual Deploy to QA Environment
deploy-qa:
  stage: deploy-qa
  image: golang:${GO_VERSION}
  variables:
    ENVIRONMENT: "qa"
    BRANCH_NAME: "qa"
  script:
    - echo "üöÄ Triggering GitHub Actions deployment to QA environment..."
    - echo "üì° Monitoring GitHub Actions workflow for branch: ${BRANCH_NAME}"
    
    # Build and run the monitor
    - cd monitor
    - go mod init github-monitor 2>/dev/null || true
    - go mod tidy
    - go build -o github-monitor main.go
    
    # Run the monitor with environment variables
    - export GITHUB_TOKEN="${GITHUB_TOKEN}"
    - export GITHUB_REPO="${GITHUB_REPO}"
    - export GITLAB_TOKEN="${GITLAB_TOKEN}"
    - export GITLAB_PROJECT_ID="${GITLAB_PROJECT_ID}"
    - export BRANCH_NAME="${BRANCH_NAME}"
    - export ENVIRONMENT="${ENVIRONMENT}"
    - export POLL_INTERVAL="10s"
    
    # Start monitoring
    - echo "üîç Starting real-time GitHub Actions monitoring..."
    - ./github-monitor
    
  artifacts:
    when: always
    paths:
      - monitor/gitlab-logs/
    expire_in: 1 week
  when: manual
  only:
    - main

# Manual Deploy to PROD Environment
deploy-prod:
  stage: deploy-prod
  image: golang:${GO_VERSION}
  variables:
    ENVIRONMENT: "prod"
    BRANCH_NAME: "main"
  script:
    - echo "üöÄ Triggering GitHub Actions deployment to PRODUCTION environment..."
    - echo "üì° Monitoring GitHub Actions workflow for branch: ${BRANCH_NAME}"
    - echo "‚ö†Ô∏è PRODUCTION DEPLOYMENT - Monitoring carefully..."
    
    # Build and run the monitor
    - cd monitor
    - go mod init github-monitor 2>/dev/null || true
    - go mod tidy
    - go build -o github-monitor main.go
    
    # Run the monitor with environment variables
    - export GITHUB_TOKEN="${GITHUB_TOKEN}"
    - export GITHUB_REPO="${GITHUB_REPO}"
    - export GITLAB_TOKEN="${GITLAB_TOKEN}"
    - export GITLAB_PROJECT_ID="${GITLAB_PROJECT_ID}"
    - export BRANCH_NAME="${BRANCH_NAME}"
    - export ENVIRONMENT="${ENVIRONMENT}"
    - export POLL_INTERVAL="5s"  # More frequent polling for production
    
    # Start monitoring
    - echo "üîç Starting real-time GitHub Actions monitoring..."
    - ./github-monitor
    
  artifacts:
    when: always
    paths:
      - monitor/gitlab-logs/
    expire_in: 1 month  # Keep prod logs longer
  when: manual
  only:
    - main

# Manual Deploy to NEXT Environment
deploy-next:
  stage: deploy-next
  image: golang:${GO_VERSION}
  variables:
    ENVIRONMENT: "next"
    BRANCH_NAME: "next"
  script:
    - echo "üöÄ Triggering GitHub Actions deployment to NEXT environment..."
    - echo "üì° Monitoring GitHub Actions workflow for branch: ${BRANCH_NAME}"
    
    # Build and run the monitor
    - cd monitor
    - go mod init github-monitor 2>/dev/null || true
    - go mod tidy
    - go build -o github-monitor main.go
    
    # Run the monitor with environment variables
    - export GITHUB_TOKEN="${GITHUB_TOKEN}"
    - export GITHUB_REPO="${GITHUB_REPO}"
    - export GITLAB_TOKEN="${GITLAB_TOKEN}"
    - export GITLAB_PROJECT_ID="${GITLAB_PROJECT_ID}"
    - export BRANCH_NAME="${BRANCH_NAME}"
    - export ENVIRONMENT="${ENVIRONMENT}"
    - export POLL_INTERVAL="10s"
    
    # Start monitoring
    - echo "üîç Starting real-time GitHub Actions monitoring..."
    - ./github-monitor
    
  artifacts:
    when: always
    paths:
      - monitor/gitlab-logs/
    expire_in: 1 week
  when: manual
  only:
    - main

# Optional: Cleanup job
cleanup:
  stage: .post
  image: alpine:latest
  script:
    - echo "üßπ Cleaning up temporary files..."
    - rm -rf /tmp/github-monitor-*
  when: always
  allow_failure: true




